import generator as gen
import random
#import schedcat.mapping.binpack as binpack
import schedcat.generator.tasks as tasks
from gen.run_task import FixedRateTask
import math
import json
from fractions import Fraction
from decimal import *
from schedcat.model.tasks import SporadicTask
import run_exps

TP_TBASE = """#for $t in $task_set
{} $t.cost $t.period
#end for"""
TP_GLOB_TASK = TP_TBASE.format("")
TP_PART_TASK = TP_TBASE.format("-p $t.cpu")
TP_RUN_TASK = TP_TBASE.format("-S $t.server")
TP_RUN_TASK_RES = TP_TBASE.format("-S $t.server #if len($t.resmodel)>0# -X RUNRSP #for $r in $t.resmodel# -Q $r -l $t.resmodel[r].max_write_length #end for# #end if#")

#ONE_MS = 1000000

def ignore(_):
    pass

class EdfGenerator(gen.Generator):
    '''Creates sporadic task sets with the most common Litmus options.'''
    def __init__(self, scheduler, templates, options, params):
        super(EdfGenerator, self).__init__(scheduler, templates,
                                           self.__make_options() + options,
                                           params)

    def __make_options(self):
        '''Return generic EDF options.'''
        return [gen.Generator._dist_option('utils', 'uni-medium',
                                           gen.NAMED_UTILIZATIONS,
                                           'Task utilization distributions.'),
                gen.Generator._dist_option('periods', 'harmonic',
                                           gen.NAMED_PERIODS,
                                           'Task period distributions.')]

    def _create_exp(self, exp_params):
        '''Create a single experiment with @exp_params in @out_dir.'''
        pdist = self._create_dist('period',
                                  exp_params['periods'],
                                  gen.NAMED_PERIODS)

        udist = self._create_dist('utilization',
                                  exp_params['utils'],
                                  gen.NAMED_UTILIZATIONS)
        
        ts = self._create_taskset(exp_params, pdist, udist)

        self._customize(ts, exp_params)

        self._write_schedule(dict(exp_params.items() + [('task_set', ts)]))
        self._write_params(exp_params)

    def _customize(self, taskset, exp_params):
        '''Configure a generated taskset with extra parameters.'''
        pass


class PartitionedGenerator(EdfGenerator):
    def __init__(self, scheduler, templates, options, params):
        super(PartitionedGenerator, self).__init__(scheduler,
            templates + [TP_PART_TASK], options, params)

    def _customize(self, taskset, exp_params):
        cpus  = exp_params['cpus']
        start = 0
        if exp_params['release_master']:
            cpus -= 1
            start = 1

        # Partition using worst-fit for most even distribution
        utils = [0]*cpus
        tasks = [0]*cpus
        for t in taskset:
            t.cpu = utils.index(min(utils))
            utils[t.cpu] += t.utilization()
            tasks[t.cpu] += 1

            # Increment by one so release master has no tasks
            t.cpu += start

class PedfGenerator(PartitionedGenerator):
    def __init__(self, params={}):
        super(PedfGenerator, self).__init__("PSN-EDF", [], [], params)


class CedfGenerator(PartitionedGenerator):
    TP_CLUSTER = "plugins/C-EDF/cluster{$level}"
    CLUSTER_OPTION = gen.GenOption('level', ['L2', 'L3', 'All'], 'L2',
                                   'Cache clustering level.',)

    def __init__(self, params={}):
        super(CedfGenerator, self).__init__("C-EDF",
                                            [CedfGenerator.TP_CLUSTER],
                                            [CedfGenerator.CLUSTER_OPTION],
                                            params)

class GedfGenerator(EdfGenerator):
    def __init__(self, params={}):
        super(GedfGenerator, self).__init__("GSN-EDF", [TP_GLOB_TASK],
                                            [], params)
        
    def _create_taskset(self, params, periods, utils, max_util = None):
        #if 'from_file' in params:
        #    ts = self._from_file('/home/davide/Documenti/Tesi/project/exps_pack/dist=uni-medium/slack_dist=servers/sched=RUN_max-util=8.0/sched.py')
        #    return ts
        if 'max_util' in params:
            max_util = float(params['max_util'])        
            if (max_util < 0.0) or (max_util > float(params['cpus'])):
                raise Exception('Incorrect max_util')
        
            tries = 0
            tg = tasks.TaskGenerator(period=periods, util=utils)
            print max_util
            ts = tg.make_task_set(max_tasks = None, max_util=max_util)
            while len(ts) <= 0 and tries < 100:
                print 'try: {0}'.format(tries)
                ts = tg.make_task_set(max_tasks = None, max_util=max_util)
                tries += 1
            print ts.utilization()
            return ts
        
        else:
            return super(GedfGenerator, self)._create_taskset(params, periods, utils, float(params['cpus']))

class RUNGenerator(EdfGenerator):
    def __init__(self, params={}):
        super(RUNGenerator, self).__init__("RUN",
            [TP_RUN_TASK2], [], params)
        self.server_count = 0

    def _from_file(self, file_name):
        with open(file_name, 'r') as f:
            data = f.read().strip()
        try:
            schedule = eval(data)
        except:
            schedule = run_exps.convert_data(data)
        ts = []
        for task_conf in schedule['task']:
            (task, args) = (task_conf[0], task_conf[1])
            real_args = args.split()
            index = 0
            if '-S' in real_args:
                index = real_args.index('-S') + 2
            ts.append(SporadicTask(int(real_args[index + 0]), int(real_args[index + 1])))
        return ts
    
    def _customize(self, taskset, exp_params):
        if 'max_util' in exp_params:
            print 'sched=RUN cpus={0} max_util={1} tasks={2}'.format(unicode(exp_params['cpus']), unicode(exp_params['max_util']), unicode(len(taskset)))
        else:
            print 'sched=RUN cpus={0} max_util={1} tasks={2}'.format(unicode(exp_params['cpus']), unicode('0.0'), unicode(len(taskset)))
        cpus  = exp_params['cpus']
        self.server_count = 0
        data = self._reductor(taskset, cpus, exp_params)
        tree_file = self.out_dir + "/tree.json"
        with open(tree_file, 'wa') as f:
            json.dump(data, f, indent=4)
            
    def _reductor(self, taskset, cpus, params):
        
        #First create fixed-rates        
        n_tasks = len(taskset)
        #On heavy task case #tasks may be less than #cpus
        if (n_tasks < cpus):
            print 'attention: #cpus has changed from {0} to {1}'.format(unicode(cpus),unicode(n_tasks))
            cpus = n_tasks
            
        t_id = 0
        fr_taskset = []
        tot_util = Fraction()
        
        for t in taskset:
            t.id = t_id
            fr_taskset.append(FixedRateTask(t.cost, t.period, t.deadline, t_id))
            t_id += 1
            tot_util += Fraction(t.cost, t.period)
        #Second distribuites unused cpu capacity (slack-pack)
        print 'Total utilization: {0}'.format(Decimal(tot_util.numerator)/Decimal(tot_util.denominator))
        
        unused_capacity = Fraction(cpus,1) - tot_util
        if (unused_capacity < Fraction()):
            raise Exception('Unfeasible Taskset')


        if self.usingResources :
          #sys.path.append("/home/luca/workspace/schedRUN/src")
          #import schedRUN.model.SystemResourceGenerator as srg
          import schedRUN.schedulability.schedulabilityRUN as sRUN
          helper = sRUN.SchedulabilityTestRUN(range(0, int(params['res_nmb'])), taskset)
          isSchedulable = helper.isSchedulable(int(params['cpus']))
          if not isSchedulable :
            raise Exception('Unfeasible Taskset with RUNRSP')
          firstLevelServers = helper.getServers()
          
          new_taskset = []
          for server in firstLevelServers :
            children = [x for x in fr_taskset if x.id in [y.id for y in server['tasks']]]
            temp_task = FixedRateTask._aggregate(children, self.server_count, 0)
            temp_task.cost = server['cost']
            temp_task.period = server['period']
            temp_task.deadline = server['period']
            self.server_count += 1
            new_taskset.append(temp_task)

          unused_capacity = Fraction(cpus,1) - sum([Fraction(x.cost, x.period) for x in new_taskset])
          new_taskset.sort(key=lambda x: x.utilization(), reverse=True)
          self._distribuite_slack(new_taskset, unused_capacity)
          self._dual(new_taskset)
          
        elif 'slack_dist' in params and params['slack_dist'] == 'tasks':
            fr_taskset.sort(key=lambda x: x.util_frac(), reverse=True)
            self._distribuite_slack(fr_taskset, unused_capacity)
            new_taskset = self._pack(fr_taskset, cpus, 0)
            self._dual(new_taskset)
        else:
            new_taskset = self._pack(fr_taskset, cpus, 0)
            new_taskset.sort(key=lambda x: x.utilization(), reverse=True)
            self._distribuite_slack(new_taskset, unused_capacity)
            self._dual(new_taskset)
        
        unit_server = self._reduce(new_taskset, 1)
        
        if (len(unit_server) != 1):
            raise Exception('Not a Unit-Server')
        
        if (unit_server[0].util_frac() != Fraction() and not(unit_server[0].util_frac().numerator == unit_server[0].util_frac().denominator)):
            raise Exception('Not a Unit-Server')
        
        print 'Root level: {0}'.format(unicode(unit_server[0].level - 1)) 
        
        for t in taskset:
            for fr_t in fr_taskset:
                if (fr_t.id == t.id):
                    t.server = fr_t.server
                    
        return FixedRateTask.serialize(unit_server[0])
    
    def _slack_dist(self, ts, slack):
        
        n_tasks = len(ts)
        val_a = ts[0].dual_utilization()
        val_b = slack / Decimal(n_tasks)
        
        unused_capacity = slack
        
        task_extra_util = min(val_a, val_b)
        for t in ts:
            if (t.dual_utilization() <= task_extra_util):
                unused_capacity -= t.dual_utilization()
                t.cost = t.period
            else:
                tmp_util = t.utilization()
                t.cost += int(task_extra_util * Decimal(t.period))
                unused_capacity -= (t.utilization() - tmp_util)
        
        tries = 10
        while (unused_capacity > Decimal(0)) and (tries > 0):
            for t in ts:
                tmp_value = unused_capacity * Decimal(t.period)
                if (t.dual_utilization() >= unused_capacity) and tmp_value == int(tmp_value):
                    t.cost += int(tmp_value)
                    unused_capacity = Decimal(0)
                    break
            if (unused_capacity > Decimal(0)):
                for t in ts:
                    if (t.dual_utilization() <= unused_capacity):
                        unused_capacity -= t.dual_utilization()
                        t.cost = t.period
            tries -= 1
            
        if (unused_capacity > Decimal(0)):
            raise Exception('Still capacity unused: ' + str(unused_capacity))
    
    def _distribuite_slack(self, ts, slack):
        ts.sort(key=lambda x: x.util_frac(), reverse=True)
        i = 0
        unused_capacity = slack        
        while (unused_capacity > Fraction()) and (i < len(ts)):
            t = ts[i]
            if (t.dual_util_frac() <= unused_capacity):
                unused_capacity -= t.dual_util_frac()
                t.cost = t.period
            else:
                tmp_frac = t.util_frac() + unused_capacity
                t.cost = tmp_frac.numerator
                t.period = tmp_frac.denominator
                unused_capacity = Fraction()
            i+=1            
        if (unused_capacity > Fraction()):
            raise Exception('Still capacity unused: ' + str(unused_capacity))
        
    def _dual(self, taskset):
        for t in taskset:
            t.cost = t.period - t.cost
        
    def _pack(self, taskset, cpus, level):
        self.misfit = 0
        n_bins = cpus
        
        taskset.sort(key=lambda x: x.util_frac(), reverse=True)
        
        bins = RUNGenerator.worst_fit(taskset, 
                                      n_bins, 
                                      Fraction(1,1), 
                                      lambda x: x.util_frac(), 
                                      self._misfit)
        while (self.misfit > 0):
            #n_bins += math.ceil(self.misfit)
            n_bins += 1 #self.misfit
            self.misfit = 0
            bins = RUNGenerator.worst_fit(taskset, 
                                          n_bins, 
                                          Fraction(1,1), 
                                          lambda x: x.util_frac(),
                                          self._misfit)    
        servers = []
        for item in bins:
            tmp_server = FixedRateTask._aggregate(item, self.server_count, level)
            servers.append(tmp_server)
            self.server_count += 1
        
        self.misfit = 0
        return servers
        
    def _misfit(self, x):
        #self.misfit += x.dual_utilization()
        self.misfit += 1
           
    def _reduce(self, taskset, level):
        utilization = Fraction()
        for t in taskset:
            utilization += t.util_frac()
        
        new_taskset = self._pack(taskset, 
                                 int(math.ceil(utilization)), 
                                 level)
        self._dual(new_taskset)
        
        if (utilization <= Fraction(1,1)):
            return new_taskset
        else:
            return self._reduce(new_taskset, level + 1)
        
    def _create_taskset(self, params, periods, utils, max_util = None):

        self.usingResources = False
        paramsRUN = [(x in params) for x in ['max_util', 'cpus']]
        paramsRes = [(x in params) for x in ['res_nmb', 'res_weight', 'res_distr']]
        if all(paramsRes) and all(paramsRUN) :
          self.usingResources = True
        elif any(paramsRes) :
          raise Exception('Some argument missing: res_nmb, res_weight, res_distr, max_util, cpus')
          
        ''' Generate system with resources '''
        if self.usingResources :

          import sys
          sys.path.append("/home/luca/workspace/schedRUN/src")
          import schedRUN.model.SystemResourceGenerator as srg

          rd = float(params['res_distr'])
          rw = float(params['res_weight'])
          rn = int(params['res_nmb'])
          ul = float(params['max_util'])
          cl = int(params['cpus'])
          tg = srg.SystemResourcesGenerator(periodDistr=periods, 
            utilDistr=utils, resDistr=rd, resWeight=rw, resNumber=rn, 
            reqNumber=1, utilLimit=ul, cpuLimit=cl)
          ts = tg.generateTaskSetLinear()

          return ts
          
        elif 'max_util' in params:
            max_util = float(params['max_util'])        
            if (max_util < 0.0) or (max_util > float(params['cpus'])):
                raise Exception('Incorrect max_util')
             
            tg = tasks.TaskGenerator(period=periods, util=utils)
            ts = tg.make_task_set(max_tasks = None, max_util=max_util)
            #print ('#%d tasks' % len(ts))
            return ts
        else:
            return super(RUNGenerator, self)._create_taskset(params, periods, utils, float(params['cpus']))
    
    @staticmethod
    def worst_fit(items, bins, capacity=Fraction(1,1), weight=id, misfit=ignore, empty_bin=list):
        sets = [empty_bin() for _ in xrange(0, bins)]
        sums = [Fraction() for _ in xrange(0, bins)]
        for x in items:
            c = weight(x)
            # pick the bin where the item will leave the most space
            # after placing it, aka the bin with the least sum
            candidates = [s for s in sums if s + c <= capacity]
            if candidates:
                # fits somewhere
                i = sums.index(min(candidates))
                sets[i] += [x]
                sums[i] += c
            else:
                misfit(x)
        return sets
         
        
